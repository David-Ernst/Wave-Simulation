/* autogenerated by Processing revision 1277 on 2023-12-14 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import controlP5.*;
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Vector;
import java.util.ArrayList;
import java.lang.Math;
import java.awt.AWTException;
import java.awt.Robot;
import java.awt.event.InputEvent;
import javax.swing.SwingUtilities;
import java.util.concurrent.CountDownLatch;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Wave_Simulation extends PApplet {
















boolean forward = false;
boolean backward = false;
boolean right = false;
boolean left = false;
boolean up = false;
boolean down = false;

boolean exited = true;
boolean paused = false;

ArrayList<String[]> waveData = new ArrayList<String[]>();
String[] simulationData = new String[]{"10", "10", "10", "100"};
boolean editSimulation = false;

GUI gui;
Simulation simulation = new Simulation();


 public void setup() {
  gui = new GUI();
  
  /* size commented out by preprocessor */;
  clear();
}

 public void draw() {
  if (!exited) {
    simulation.update();
    if(gui.controlFrame != null){
       gui.controlFrame.dispose();
       gui.controlFrame.disposed = true;
    }
  } else {
    if(gui.controlFrame.disposed && exited == true) {
      gui = new GUI();
    }
    cursor();
    simulation.setWaves(waveData);
    if (editSimulation) {
      simulation.setSandbox(simulationData);
      editSimulation = false;
    }
  }
}

 public void keyReleased() {
  if (keyCode == SHIFT) {
    down = false;
  }
  if (key == ESC) {
    exited = !exited;
    key = 0;
  }
  if (key == ' ') {
    up = false;
  }



  if (key == 'w' || key =='W') {
    forward = false;
  }
  if (key == 's' || key == 'S') {
    backward = false;
  }

  if (key == 'a' || key == 'A') {
    left = false;
  }
  if (key == 'd' || key == 'D') {
    right = false;
  }
}

 public void keyPressed() {
  if (keyPressed) {
    if (key == CODED) {
      if (keyCode == SHIFT) {
        down = true;
      }
    }
    if (key == ' ') {
      up = true;
    }
    if (key == 'p' || key == 'P') {
      paused = !paused;
      key = 0;
    }
    if (key == 'w' || key =='W') {
      forward = true;
    }
    if (key == 's' || key == 'S') {
      backward = true;
    }

    if (key == 'a' || key == 'A') {
      left = true;
    }
    if (key == 'd' || key == 'D') {
      right = true;
    }
    if (key == ESC) key = 0;
    if (key == 'r') {
      simulation.timer.reset();
    }
  }
}
class Camera {
  private PVector camPos;
  private PVector camCenter;
  private PVector directionDegree;
  private PVector direction;
  private float speed;



  Robot robot;

  private PVector mouseVec;
  private float camSensitivity;

  Camera() {
    camPos = new PVector(width/2.0f, height/2.0f, 100);
    camCenter = new PVector(width/2.0f, height/2.0f+1, 0);
    direction = new PVector(0, 1.0f, 0);
    directionDegree = new PVector(0, 0.0f);
    speed = 5;

    camSensitivity = 0.06f;
    mouseVec = new PVector(0, 0);

    try {
      robot = new Robot();
    }
    catch (AWTException e) {
      e.printStackTrace();
    }
  }

  public void update() {
    handleInputs();
    camera(camPos.x, camPos.y, camPos.z, camCenter.x + camPos.x, camCenter.y + camPos.y, camCenter.z + camPos.z, 0.0f, 0.0f, 1.0f);
  }

  private void handleInputs() {
    // Vector from the middle to the mouse position
    mouseVec.x = mouseX - (width/2);
    mouseVec.y = mouseY - (height/2);

    // The camera angle is multiplied by its sensitivity and added to the vector
    directionDegree.x = directionDegree.x - mouseVec.x * camSensitivity;
    directionDegree.y = directionDegree.y + mouseVec.y * camSensitivity;

    // The mouse position is set to the middle of the screen
    robot.mouseMove(width/2, height/2);

    if (!keyPressed) {
      up = false;
      down = false;
      forward = false;
      backward = false;
      right = false;
      left = false;
    }

    if (up) {
      camPos.z = camPos.z - speed;
    }
    if (down) {
      camPos.z = camPos.z + speed;
    }
    if (forward) {
      camPos = camPos.add(direction.mult(speed));
      direction.normalize();
    }
    if (backward) {
      camPos = camPos.add(direction.mult(-speed));
      direction.normalize();
    }
    if (!backward) {
      if (right) {
        camPos = camPos.add(perpendicularVector(direction.mult(speed)));
        direction.normalize();
      }
      if (left) {
        camPos = camPos.add(perpendicularVector(direction.mult(-speed)));
        direction.normalize();
      }
    }else{
      if (right) {
        camPos = camPos.add(perpendicularVector(direction.mult(-speed)));
        direction.normalize();
      }
      if (left) {
        camPos = camPos.add(perpendicularVector(direction.mult(speed)));
        direction.normalize();
      }
    }

    if (directionDegree.y > 89) directionDegree.y = 89;
    if (directionDegree.y < -89) directionDegree.y = -89;
    camCenter.x = cos(directionDegree.x * PI/180) * cos(directionDegree.y * PI/180);
    camCenter.y = sin(directionDegree.x * PI/180) * cos(directionDegree.y * PI/180);
    camCenter.z = sin(directionDegree.y * PI/180);

    direction = new PVector(camCenter.x, camCenter.y);
    direction.normalize();
  }

  private PVector perpendicularVector(PVector v) {
    return new PVector(v.y, -v.x);
  }
}
class ControlFrame extends JFrame {
  public boolean disposed = false;

  public ControlFrame() {
    setTitle("Control Frame");
    setSize(200, 300);
    setLocation(width/2-100, height/2-150);
    setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);

    JButton openWaves = new JButton("Open Wave List");
    openWaves.addActionListener(new ActionListener() {
      @Override
        public void actionPerformed(ActionEvent e) {
        // Create and display the main frame with data from the ArrayList
        WaveTable waveTable = new WaveTable(waveData);
        waveTable.setVisible(true);
      }
    }
    );
    JButton editSandbox = new JButton("Edit Sandbox");
    editSandbox.addActionListener(new ActionListener() {
      @Override
        public void actionPerformed(ActionEvent e) {
        // Create and display the main frame with data from the ArrayList
        SandboxEditor sandboxEditor = new SandboxEditor(simulationData);
        sandboxEditor.setVisible(true);
      }
    }
    );
    JButton exitAll = new JButton("Exit");
    exitAll.addActionListener(new ActionListener() {
      @Override
        public void actionPerformed(ActionEvent e) {
        // Create and display the main frame with data from the ArrayList
        exit();
      }
    }
    );
    JButton moveToBack = new JButton("Go to Simulation");
    moveToBack.addActionListener(new ActionListener() {
      @Override
        public void actionPerformed(ActionEvent e) {
        disposed = true;
        dispose();
        exited = false;
      }
    }
    );

    setLayout(new GridLayout(4, 1));
    add(moveToBack);
    add(openWaves);
    add(editSandbox);
    add(exitAll);
  }
}



class GUI {
  public ControlFrame controlFrame;

  GUI() {
    // Create a CountDownLatch with initial count 1
    CountDownLatch latch = new CountDownLatch(1);

    createControlFrame(latch);

    try {
      // Wait for the latch to count down to zero
      latch.await();
    }
    catch (InterruptedException e) {
      e.printStackTrace();
    }
  }

  public void createControlFrame(CountDownLatch latch) {
    SwingUtilities.invokeLater(() -> {
      // Check if the controlFrame is already initialized
      if (this.controlFrame == null) {
        this.controlFrame = new ControlFrame();
        this.controlFrame.setVisible(true);
        this.controlFrame.toFront();
      }

      // Count down the latch to signal completion
      latch.countDown();
    }
    );
  }
}
class Particle {
  final public float x;  //in m
  final public float y;  //in m
  public float z;        //in m
  private ArrayList<Wave> waves;
  private ArrayList<Float> distances;

  Particle(float x, float y) {
    this.x = x;
    this.y = y;
    this.z = 0f;
  }

  public void addWaveList(ArrayList<Wave> waves) {
    this.waves = waves;
    distances = new ArrayList<Float>();
    for (Wave wave : this.waves) {
      distances.add(wave.calculateDistance(this.x, this.y));
    }
  }

  public void update() {
    z = 0f;
    if (waves.size() != distances.size()) addWaveList(waves);
    if (waves.isEmpty()) return;
    for (int i = 0; i < waves.size(); i++) {
      Wave wave = waves.get(i);
      z = z + wave.calculateAmplitude(distances.get(i));
    }
  }
}
class ParticleField {
  private ArrayList<Wave> waves;
  private Particle[][] field;
  private float density = 10f;  //Particles per Meter
  private float resolution = 100f;  //Pixel per Meter

  ParticleField(float x, float y, float density) {
    waves = new ArrayList<Wave>();
    this.density = density;
    createField(x, y, this.density);
  }

  public ArrayList<Wave> getWaves() {
    return waves;
  }

  public void setWaves(ArrayList<Wave> waves) {
    this.waves = waves;
    for (int i = 0; i < field.length; i++) {
      for (int j = 0; j < field[0].length; j++) {
        field[i][j].addWaveList(this.waves);
      }
    }
  }

  public void setResolution(float resolution) {
    this.resolution = resolution;
  }

  // IMPORTANT: Execute this first!
  public void createField(float x, float y, float density) {
    if (density == 0) return;
    int xLength = PApplet.parseInt(x*density);
    int yLength = PApplet.parseInt(y*density);
    field = new Particle[xLength][yLength];
    for (int i = 0; i < xLength; i++) {
      for (int j = 0; j < yLength; j++) {
        field[i][j] = new Particle(PApplet.parseFloat(i)/density, PApplet.parseFloat(j)/density);
      }
    }
  }

  public void update() {
    for (int i = 0; i < field.length; i++) {
      for (int j = 0; j < field[0].length; j++) {
        field[i][j].update();
      }
    }
  }

  public void render() {
    for (int i = 0; i < field.length; i++) {
      for (int j = 0; j < field[0].length; j++) {
        stroke(255);
        point(field[i][j].x * resolution, field[i][j].y * resolution, field[i][j].z * resolution * -1);
      }
    }
  }

  public void renderTriangle() {

    for (int i = 0; i < field.length-1; i++) {
      for (int j = 0; j < field[0].length-1; j++) {

        noFill();
        stroke(64, 64, 255);
        strokeWeight(1);
        beginShape(TRIANGLE_STRIP);
        vertex(field[i][j].x * resolution, field[i][j].y * resolution, field[i][j].z * resolution * -1);
        vertex(field[i+1][j].x * resolution, field[i+1][j].y * resolution, field[i+1][j].z * resolution * -1);
        vertex(field[i+1][j+1].x * resolution, field[i+1][j+1].y * resolution, field[i+1][j+1].z * resolution * -1);
        endShape();
      }
    }
  }
}
class SandboxEditor extends JFrame {
  private JTextField textField1, textField2, textField3, textField4;
  private JButton saveButton;

  public SandboxEditor(String[] initialData) {
    setTitle("Edit Sandbox");
    setSize(400, 200);

    textField1 = new JTextField(20);
    textField2 = new JTextField(20);
    textField3 = new JTextField(20);
    textField4 = new JTextField(20);

    if (initialData.length > 3) {
      textField1.setText(initialData[0]);
      textField2.setText(initialData[1]);
      textField3.setText(initialData[2]);
      textField4.setText(initialData[3]);
    }

    saveButton = new JButton("Save");

    saveButton.addActionListener(new ActionListener() {
      @Override
        public void actionPerformed(ActionEvent e) {

        simulationData[0] = textField1.getText();
        simulationData[1] = textField2.getText();
        simulationData[2] = textField3.getText();
        simulationData[3] = textField4.getText();


        editSimulation = true;
      }
    }
    );

    JPanel panel = new JPanel();
    panel.setLayout(new GridLayout(5, 2));
    panel.add(new JLabel("Width:"));
    panel.add(textField1);
    panel.add(new JLabel("Height:"));
    panel.add(textField2);
    panel.add(new JLabel("Density:"));
    panel.add(textField3);
    panel.add(new JLabel("Resolution:"));
    panel.add(textField4);
    panel.add(saveButton);

    add(panel);

    setVisible(true);
  }
}
class Simulation {

  Camera cam;
  Timer timer;
  ParticleField f = new ParticleField(10, 10, 10);

  ArrayList<Wave> waves;

  Simulation() {

    cam = new Camera();

    timer = new Timer();
    waves = new ArrayList<Wave>();

    f.setWaves(waves);
  }

   public void update() {
    beginCamera();
    noCursor();
    clear();
    rotateX(PI/3);
    cam.update();
    timer.execute();
    f.update();
    f.renderTriangle();
    endCamera();
  }

   public void setSandbox(String[] data) {
    if (data.length != 4) return;
    float x = strToFloat(data[0]);
    if (x <= 0) x = 10;
    float y = strToFloat(data[1]);
    if (y <= 0) y = 10;
    float density = strToFloat(data[2]);
    if (density <= 0) density = 10;
    float resolution = strToFloat(data[3]);
    if (resolution <= 0) resolution = 100;

    f = new ParticleField(x, y, density);
    f.setResolution(resolution);

    f.setWaves(waves);
  }

   public void setWaves(ArrayList<String[]> strList) {
    waves = new ArrayList<Wave>();
    for (String[] s : strList) {
      Wave wave = new Wave(strToFloat(s[0]), strToFloat(s[1]));
      wave.setAmplitude(strToFloat(s[2]));
      wave.setWavelength(strToFloat(s[3]));
      wave.setWavespeed(strToFloat(s[4]));
      wave.setStartTime(strToFloat(s[5]));
      wave.setPhaseConstant(strToFloat(s[6]));

      wave.addTimer(timer);

      waves.add(wave);
    }
    f.setWaves(waves);
  }

   public float strToFloat(String s) {
    float floatVal;

    try {
      floatVal = Float.parseFloat(s);
      return floatVal;
    }
    catch (Exception e) {
      return 0f;
    }
  }
}
class Timer {
  private long lastTime;  // In Milliseconds
  private float currentTime;  // In Seconds
  private float factor = 1f;

  Timer() {
    reset();
  }

  public void reset() {
    lastTime = System.currentTimeMillis();
    this.currentTime = 0f;
  }

  public void setFactor(float factor) {
    this.factor = factor;
  }
  
  public void pause(){
    lastTime = System.currentTimeMillis();
  }
  
  public void execute() {
    if(paused) pause();
    long passedTimeLong = System.currentTimeMillis() - this.lastTime;
    if(passedTimeLong > 500){
      lastTime = System.currentTimeMillis();
      return;
    }
    float passedTimeFloat = (float)(passedTimeLong) / 1000f;                  // Convert from Milliseconds to Seconds
    this.currentTime = this.currentTime + (passedTimeFloat * this.factor);
    
    lastTime = System.currentTimeMillis();
  }

  public float getTime() {
    return this.currentTime;
  }
}
class Wave {
  private float x;  // In m
  private float y;  // In m

  private float s;  // Maximum amplitude of the wave in m
  private float λ;  // Wavelength in m
  private float c;  // Wave velocity in m/s
  private float ω;  // Angular frequenzy
  private float k;  // Wave number (measure of the spatial frequency of the wave)
  private float ϕ;  // The phase shift of the wave
  private float startTime; //At which point in time the wave starts

  private Timer timer;

  Wave(float x, float y) {
    this.x = x;
    this.y = y;
    s = 0f;
    λ = 0f;
    c = 0f;
    ω = 0f;
    k = 0f;
    ϕ = 0f;
    startTime = 0f;
  }
  
  public void setStartTime(float startTime){
    this.startTime = startTime;
  }
  
  public void addTimer(Timer timer) {
    this.timer = timer;
  }

  public void setAmplitude(float s) {
    this.s = s;
  }

  public void setWavelength(float λ) {
    this.λ = λ;
    if (λ == 0) return;
    this.k = (2 * PI) / λ;
    if (this.c == 0) return;
    ω = (c / λ) * 2*PI;
  }

  public void setWavespeed(float c) {
    this.c = c;
    if (this.c == 0) return;
    if (λ == 0) return;
    ω = (c / λ) * 2*PI;
  }
  
  public void setPhaseConstant(float ϕ){
    this.ϕ = ϕ;
  }

  public float calculateAmplitude(float x) {
    float t = timer.getTime();
    if (x > (t - startTime) * c) return 0f;
    return -s * sin(k * x - ω * (t - startTime) + ϕ);
  }

  public float calculateDistance(float x, float y) {
    return dist(x, y, this.x, this.y);
  }
}
class WaveTable extends JFrame {
  private JTable table;
  private DefaultTableModel tableModel;
  private ArrayList<String[]> savedData;

  public WaveTable(ArrayList<String[]> initialData) {
    this.savedData = initialData; // Initialize savedData with the provided initial data

    setTitle("Main Frame");
    setSize(400, 300);
    setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);

    // Initialize the table model with column names
    // Create a DefaultTableModel with three columns
    Vector<String> columnNames = new Vector<String>();
    columnNames.add("x-Coordinate");
    columnNames.add("y-Coordinate");
    columnNames.add("ŝ");
    columnNames.add("λ");
    columnNames.add("c");
    columnNames.add("start time");
    columnNames.add("ϕ");
    tableModel = new DefaultTableModel(columnNames, 0);

    // Create a 2D Vector to hold the table data
    Vector<Vector<String>> tableData = new Vector<>();
    for (String[] rowData : initialData) {
      tableData.add(new Vector<>(java.util.Arrays.asList(rowData)));
    }

    tableModel = new DefaultTableModel(tableData, columnNames);
    table = new JTable(tableModel);
    table.setDefaultEditor(Object.class, new DefaultCellEditor(new JTextField()));
    JScrollPane scrollPane = new JScrollPane(table);

    // A table model listener to save data when it changes
    tableModel.addTableModelListener(new TableModelListener() {
      @Override
        public void tableChanged(TableModelEvent e) {
        int row = e.getFirstRow();
        int column = e.getColumn();
        if (row >= 0 && column >= 0) {
          String value = (String) tableModel.getValueAt(row, column);
          savedData.get(row)[column] = value;
        }
      }
    }
    );

    JPanel buttonPanel = new JPanel();
    JButton addButton = new JButton("Add Row");
    addButton.addActionListener(new ActionListener() {
      @Override
        public void actionPerformed(ActionEvent e) {
        // Add a new empty row to the table and savedData
        Vector<String> newRow = new Vector<>();
        String[] newSavedRow = new String[columnNames.size()];
        for (int i = 0; i < columnNames.size(); i++) {
          newRow.add("");
          newSavedRow[i] = "";
        }
        tableModel.addRow(newRow);
        savedData.add(newSavedRow);
      }
    }
    );

    JButton removeButton = new JButton("Remove Row");
    removeButton.addActionListener(new ActionListener() {
      @Override
        public void actionPerformed(ActionEvent e) {
        // Remove the selected row from the table and savedData
        int selectedRow = table.getSelectedRow();
        if (selectedRow >= 0) {
          tableModel.removeRow(selectedRow);
          savedData.remove(selectedRow);
        }
      }
    }
    );

    JButton saveButton = new JButton("Save Data");
    saveButton.addActionListener(new ActionListener() {
      @Override
        public void actionPerformed(ActionEvent e) {
        saveData(savedData);
      }
    }
    );

    buttonPanel.add(addButton);
    buttonPanel.add(removeButton);
    buttonPanel.add(saveButton);

    setLayout(new BorderLayout());
    add(scrollPane, BorderLayout.CENTER);
    add(buttonPanel, BorderLayout.SOUTH);
  }

  private void saveData(ArrayList<String[]> dataToSave) {
    waveData = dataToSave;
  }
}


  public void settings() { fullScreen(P3D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Wave_Simulation" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
